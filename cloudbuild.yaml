steps:
  # Step to install dependencies
  - id: pip-install
    name: 'python:3.9-slim'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        python -m venv venv && \
        . venv/bin/activate && \
        pip install -r requirements.txt

  # Step to build the Docker image
  - id: build
    name: 'gcr.io/cloud-builders/docker'
    args:
      - 'build'
      - '--target'
      - 'production'
      - '-t'
      - '$_AR_HOSTNAME/$_PROJECT_ID/$_AR_REPO/$_SERVICE_NAME:$COMMIT_SHA'
      - '.'

  # Step to push the Docker image
  - id: push
    name: 'gcr.io/cloud-builders/docker'
    args:
      - 'push'
      - '$_AR_HOSTNAME/$_PROJECT_ID/$_AR_REPO/$_SERVICE_NAME:$COMMIT_SHA'

  # Step to get secrets
  - id: get-secret
    name: 'gcr.io/cloud-builders/gcloud'
    entrypoint: 'bash'
    args:
      [
        '-c',
        "gcloud secrets versions access latest --secret=$_SECRET --format='get(payload.data)' | tr '_-' '/+' | base64 -d > /workspace/env.yaml",
      ]

  # Deploy to the primary region
  - id: deploy-region-primary
    name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    entrypoint: 'gcloud'
    args:
      - 'run'
      - 'deploy'
      - '$_SERVICE_NAME'
      - '--image'
      - '$_AR_HOSTNAME/$_PROJECT_ID/$_AR_REPO/$_SERVICE_NAME:$COMMIT_SHA'
      - '--region'
      - '$_PRIMARY_REGION'
      - "--env-vars-file=/workspace/env.yaml"
      - '--project'
      - '$_PROJECT_ID'
      - '--set-cloudsql-instances'
      - '$_CLOUDSQL_INSTANCE'
      - '--vpc-connector=$_VPC_CONNECTOR'
      - '--min-instances=3'
      - '--max-instances=5'
      - '--cpu=2'
      - '--memory=2Gi'

  # Deploy to the secondary region
  - id: deploy-region-secondary
    name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    entrypoint: 'gcloud'
    args:
      - 'run'
      - 'deploy'
      - '$_SERVICE_NAME'
      - '--image'
      - '$_AR_HOSTNAME/$_PROJECT_ID/$_AR_REPO/$_SERVICE_NAME:$COMMIT_SHA'
      - '--region'
      - '$_SECONDARY_REGION'
      - "--env-vars-file=/workspace/env.yaml"
      - '--project'
      - '$_PROJECT_ID'
      - '--set-cloudsql-instances'
      - '$_CLOUDSQL_INSTANCE'
      - '--vpc-connector=$_VPC_CONNECTOR-$_SECONDARY_REGION'
      - '--min-instances=3'
      - '--max-instances=5'
      - '--cpu=2'
      - '--memory=2Gi'

  - id: reserve-global-static-ip
    name: 'gcr.io/cloud-builders/gcloud'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        IP_NAME="${_SERVICE_NAME}-ip"
        if ! gcloud compute addresses describe "$IP_NAME" --global &> /dev/null; then
          echo "Reserving global static IP..."
          gcloud compute addresses create "$IP_NAME" \
            --global \
            --network-tier=STANDARD
        else
          echo "Global static IP $IP_NAME already exists."
        fi

  # Crear NEGs sin servidores para cada región
  - id: create-serverless-negs
    name: 'gcr.io/cloud-builders/gcloud'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        for region in $_PRIMARY_REGION $_SECONDARY_REGION; do
          NEG_NAME="${_SERVICE_NAME}-${region}-neg"
          if ! gcloud compute network-endpoint-groups describe "$NEG_NAME" --region="$region" &> /dev/null; then
            echo "Creating Serverless NEG $NEG_NAME in $region..."
            gcloud compute network-endpoint-groups create "$NEG_NAME" \
              --region="$region" \
              --network-endpoint-type=serverless \
              --cloud-run-service=$_SERVICE_NAME
          else
            echo "Serverless NEG $NEG_NAME already exists in $region."
          fi
        done

  # Crear un backend service global si no existe
  - id: create-global-backend-service
    name: 'gcr.io/cloud-builders/gcloud'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        BACKEND_NAME="${_SERVICE_NAME}-global-backend"
        if ! gcloud compute backend-services describe "$BACKEND_NAME" --global &> /dev/null; then
          echo "Creating Global Backend Service..."
          gcloud compute backend-services create "$BACKEND_NAME" \
            --global \
            --load-balancing-scheme=EXTERNAL_MANAGED \
            --protocol=HTTP
          
          for region in $_PRIMARY_REGION $_SECONDARY_REGION; do
            NEG_NAME="${_SERVICE_NAME}-${region}-neg"
            echo "Adding NEG $NEG_NAME to $BACKEND_NAME..."
            gcloud compute backend-services add-backend "$BACKEND_NAME" \
              --global \
              --network-endpoint-group="$NEG_NAME" \
              --network-endpoint-group-region="$region"
          done
        else
          echo "Global Backend Service $BACKEND_NAME already exists."
        fi

  # Crear un URL map global si no existe
  - id: create-global-url-map
    name: 'gcr.io/cloud-builders/gcloud'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        URL_MAP_NAME="${_SERVICE_NAME}-global-url-map"
        BACKEND_NAME="${_SERVICE_NAME}-global-backend"
        if ! gcloud compute url-maps describe "$URL_MAP_NAME" --global &> /dev/null; then
          echo "Creating Global URL Map..."
          gcloud compute url-maps create "$URL_MAP_NAME" \
            --global \
            --default-service="$BACKEND_NAME"
        else
          echo "Global URL Map $URL_MAP_NAME already exists."
        fi

  # Crear una regla de reenvío global si no existe
  - id: create-global-forwarding-rule
    name: 'gcr.io/cloud-builders/gcloud'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        FORWARDING_RULE_NAME="${_SERVICE_NAME}-forwarding-rule"
        URL_MAP_NAME="${_SERVICE_NAME}-global-url-map"
        IP_NAME="${_SERVICE_NAME}-ip"
        if ! gcloud compute forwarding-rules describe "$FORWARDING_RULE_NAME" --global &> /dev/null; then
          echo "Creating Global Forwarding Rule..."
          gcloud compute forwarding-rules create "$FORWARDING_RULE_NAME" \
            --global \
            --target-http-proxy="$URL_MAP_NAME" \
            --address="$IP_NAME" \
            --ports=80
        else
          echo "Global Forwarding Rule $FORWARDING_RULE_NAME already exists."
        fi

options:
  logging: CLOUD_LOGGING_ONLY